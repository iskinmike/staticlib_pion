<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>staticlib_pion: staticlib::pion::tcp_connection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">staticlib_pion
   &#160;<span id="projectnumber">5.0.7-15</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestaticlib.html">staticlib</a></li><li class="navelem"><a class="el" href="namespacestaticlib_1_1pion.html">pion</a></li><li class="navelem"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html">tcp_connection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classstaticlib_1_1pion_1_1tcp__connection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">staticlib::pion::tcp_connection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a single tcp connection.  
 <a href="classstaticlib_1_1pion_1_1tcp__connection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tcp__connection_8hpp_source.html">staticlib/pion/tcp_connection.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection_1_1ssl__socket__type.html">ssl_socket_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy data type for an SSL-like socket connection in non-SSL environment.  <a href="classstaticlib_1_1pion_1_1tcp__connection_1_1ssl__socket__type.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af7739a76fa0ebcd726b216a02d3905d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#af7739a76fa0ebcd726b216a02d3905d2">lifecycle_type</a> { <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#af7739a76fa0ebcd726b216a02d3905d2a332410340ccbf38c84577953e6cd5e3d">LIFECYCLE_CLOSE</a>, 
<a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#af7739a76fa0ebcd726b216a02d3905d2a8d28aff983d92863db399f4c6d925eea">LIFECYCLE_KEEPALIVE</a>, 
<a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#af7739a76fa0ebcd726b216a02d3905d2a13bede81a0795f5e0c752925a24f8ba5">LIFECYCLE_PIPELINED</a>
 }</td></tr>
<tr class="memdesc:af7739a76fa0ebcd726b216a02d3905d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for the connection's lifecycle state.  <a href="classstaticlib_1_1pion_1_1tcp__connection.html#af7739a76fa0ebcd726b216a02d3905d2">More...</a><br/></td></tr>
<tr class="memitem:ae5075699acd8e07b6d242f3cf70690eb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#ae5075699acd8e07b6d242f3cf70690eba5a53cbdf95cf6402baca981c3ac1edf5">READ_BUFFER_SIZE</a> =  8192
 }</td></tr>
<tr class="memdesc:ae5075699acd8e07b6d242f3cf70690eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the read buffer.  <a href="classstaticlib_1_1pion_1_1tcp__connection.html#ae5075699acd8e07b6d242f3cf70690eb">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46fbdd6543ae39d83c1ba13e06407187"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a46fbdd6543ae39d83c1ba13e06407187">tcp_connection</a> (const <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html">tcp_connection</a> &amp;)</td></tr>
<tr class="memdesc:a46fbdd6543ae39d83c1ba13e06407187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="#a46fbdd6543ae39d83c1ba13e06407187"></a><br/></td></tr>
<tr class="memitem:a28a61b43aa04174d7ee5fa46f9ee6d24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html">tcp_connection</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a28a61b43aa04174d7ee5fa46f9ee6d24">operator=</a> (const <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html">tcp_connection</a> &amp;)</td></tr>
<tr class="memdesc:a28a61b43aa04174d7ee5fa46f9ee6d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <a href="#a28a61b43aa04174d7ee5fa46f9ee6d24"></a><br/></td></tr>
<tr class="memitem:adf54c5d576428f3dad96d5e9fbbd3d2b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#adf54c5d576428f3dad96d5e9fbbd3d2b">~tcp_connection</a> ()</td></tr>
<tr class="memdesc:adf54c5d576428f3dad96d5e9fbbd3d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="#adf54c5d576428f3dad96d5e9fbbd3d2b"></a><br/></td></tr>
<tr class="memitem:ac8680cd33e5dc496a5e3e089721467d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#ac8680cd33e5dc496a5e3e089721467d3">is_open</a> () const </td></tr>
<tr class="memdesc:ac8680cd33e5dc496a5e3e089721467d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the connection is currently open.  <a href="#ac8680cd33e5dc496a5e3e089721467d3"></a><br/></td></tr>
<tr class="memitem:aea40b6af13e5d03da75c8c87fd000dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#aea40b6af13e5d03da75c8c87fd000dec">close</a> ()</td></tr>
<tr class="memdesc:aea40b6af13e5d03da75c8c87fd000dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the tcp socket and cancels any pending asynchronous operations.  <a href="#aea40b6af13e5d03da75c8c87fd000dec"></a><br/></td></tr>
<tr class="memitem:ab543525ac858c658ab6ff4d29876402e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#ab543525ac858c658ab6ff4d29876402e">cancel</a> ()</td></tr>
<tr class="memdesc:ab543525ac858c658ab6ff4d29876402e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels any asynchronous operations pending on the socket.  <a href="#ab543525ac858c658ab6ff4d29876402e"></a><br/></td></tr>
<tr class="memitem:a40d92a984e127cbfeed5256c88c0aefb"><td class="memTemplParams" colspan="2">template&lt;typename AcceptHandler &gt; </td></tr>
<tr class="memitem:a40d92a984e127cbfeed5256c88c0aefb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a40d92a984e127cbfeed5256c88c0aefb">async_accept</a> (asio::ip::tcp::acceptor &amp;tcp_acceptor, AcceptHandler handler)</td></tr>
<tr class="memdesc:a40d92a984e127cbfeed5256c88c0aefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously accepts a new tcp connection.  <a href="#a40d92a984e127cbfeed5256c88c0aefb"></a><br/></td></tr>
<tr class="memitem:a3b074f3af081116069a4c7c876e4a150"><td class="memTemplParams" colspan="2">template&lt;typename SSLHandshakeHandler &gt; </td></tr>
<tr class="memitem:a3b074f3af081116069a4c7c876e4a150"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a3b074f3af081116069a4c7c876e4a150">async_handshake_server</a> (SSLHandshakeHandler handler)</td></tr>
<tr class="memdesc:a3b074f3af081116069a4c7c876e4a150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously performs server-side SSL handshake for a new connection.  <a href="#a3b074f3af081116069a4c7c876e4a150"></a><br/></td></tr>
<tr class="memitem:a4923a9f45475729adf513f759277ac1e"><td class="memTemplParams" colspan="2">template&lt;typename ReadHandler &gt; </td></tr>
<tr class="memitem:a4923a9f45475729adf513f759277ac1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a4923a9f45475729adf513f759277ac1e">async_read_some</a> (ReadHandler handler)</td></tr>
<tr class="memdesc:a4923a9f45475729adf513f759277ac1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads some data into the connection's read buffer.  <a href="#a4923a9f45475729adf513f759277ac1e"></a><br/></td></tr>
<tr class="memitem:a409bd7aa4e217aa44c93808195bc3ceb"><td class="memTemplParams" colspan="2">template&lt;typename ReadBufferType , typename ReadHandler &gt; </td></tr>
<tr class="memitem:a409bd7aa4e217aa44c93808195bc3ceb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a409bd7aa4e217aa44c93808195bc3ceb">async_read_some</a> (ReadBufferType read_buffer, ReadHandler handler)</td></tr>
<tr class="memdesc:a409bd7aa4e217aa44c93808195bc3ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads some data into the connection's read buffer.  <a href="#a409bd7aa4e217aa44c93808195bc3ceb"></a><br/></td></tr>
<tr class="memitem:a4ec827d9efd92fd0f9e559ff18675bf0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a4ec827d9efd92fd0f9e559ff18675bf0">read_some</a> (std::error_code &amp;ec)</td></tr>
<tr class="memdesc:a4ec827d9efd92fd0f9e559ff18675bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads some data into the connection's read buffer (blocks until finished)  <a href="#a4ec827d9efd92fd0f9e559ff18675bf0"></a><br/></td></tr>
<tr class="memitem:a4dea910f609f794b9b49d045c7941ea8"><td class="memTemplParams" colspan="2">template&lt;typename ReadBufferType &gt; </td></tr>
<tr class="memitem:a4dea910f609f794b9b49d045c7941ea8"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a4dea910f609f794b9b49d045c7941ea8">read_some</a> (ReadBufferType read_buffer, std::error_code &amp;ec)</td></tr>
<tr class="memdesc:a4dea910f609f794b9b49d045c7941ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads some data into the connection's read buffer (blocks until finished)  <a href="#a4dea910f609f794b9b49d045c7941ea8"></a><br/></td></tr>
<tr class="memitem:ae8e9e3f821c8e283db153780e1c58c67"><td class="memTemplParams" colspan="2">template&lt;typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ae8e9e3f821c8e283db153780e1c58c67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#ae8e9e3f821c8e283db153780e1c58c67">async_read</a> (CompletionCondition completion_condition, ReadHandler handler)</td></tr>
<tr class="memdesc:ae8e9e3f821c8e283db153780e1c58c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads data into the connection's read buffer until completion_condition is met.  <a href="#ae8e9e3f821c8e283db153780e1c58c67"></a><br/></td></tr>
<tr class="memitem:add5c20d2263b87338ad21791aab139bc"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:add5c20d2263b87338ad21791aab139bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#add5c20d2263b87338ad21791aab139bc">async_read</a> (const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadHandler handler)</td></tr>
<tr class="memdesc:add5c20d2263b87338ad21791aab139bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously reads data from the connection until completion_condition is met.  <a href="#add5c20d2263b87338ad21791aab139bc"></a><br/></td></tr>
<tr class="memitem:a49ff1778a2e20be8567407923d549ba3"><td class="memTemplParams" colspan="2">template&lt;typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a49ff1778a2e20be8567407923d549ba3"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a49ff1778a2e20be8567407923d549ba3">read</a> (CompletionCondition completion_condition, std::error_code &amp;ec)</td></tr>
<tr class="memdesc:a49ff1778a2e20be8567407923d549ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the connection's read buffer until completion_condition is met (blocks until finished)  <a href="#a49ff1778a2e20be8567407923d549ba3"></a><br/></td></tr>
<tr class="memitem:a191460097d9a98013f65d0c96720060e"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:a191460097d9a98013f65d0c96720060e"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a191460097d9a98013f65d0c96720060e">read</a> (const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, std::error_code &amp;ec)</td></tr>
<tr class="memdesc:a191460097d9a98013f65d0c96720060e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from the connection until completion_condition is met (blocks until finished)  <a href="#a191460097d9a98013f65d0c96720060e"></a><br/></td></tr>
<tr class="memitem:a5db24f8061bf474f8016f28350f4e6dd"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , typename write_handler_t &gt; </td></tr>
<tr class="memitem:a5db24f8061bf474f8016f28350f4e6dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a5db24f8061bf474f8016f28350f4e6dd">async_write</a> (const ConstBufferSequence &amp;buffers, write_handler_t handler)</td></tr>
<tr class="memdesc:a5db24f8061bf474f8016f28350f4e6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously writes data to the connection.  <a href="#a5db24f8061bf474f8016f28350f4e6dd"></a><br/></td></tr>
<tr class="memitem:aba716e2b4c3c817fc33d54ba5ae32448"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:aba716e2b4c3c817fc33d54ba5ae32448"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#aba716e2b4c3c817fc33d54ba5ae32448">write</a> (const ConstBufferSequence &amp;buffers, std::error_code &amp;ec)</td></tr>
<tr class="memdesc:aba716e2b4c3c817fc33d54ba5ae32448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the connection (blocks until finished)  <a href="#aba716e2b4c3c817fc33d54ba5ae32448"></a><br/></td></tr>
<tr class="memitem:a76c2df67070743bebd109f343eab8aec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a76c2df67070743bebd109f343eab8aec">finish</a> ()</td></tr>
<tr class="memdesc:a76c2df67070743bebd109f343eab8aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called when a server has finished handling the connection.  <a href="#a76c2df67070743bebd109f343eab8aec"></a><br/></td></tr>
<tr class="memitem:a960711882583673805a4c46a62f70375"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a960711882583673805a4c46a62f70375">get_ssl_flag</a> () const </td></tr>
<tr class="memdesc:a960711882583673805a4c46a62f70375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the connection is encrypted using SSL.  <a href="#a960711882583673805a4c46a62f70375"></a><br/></td></tr>
<tr class="memitem:a985322bd233478e3c2d287d6bf5f7948"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a985322bd233478e3c2d287d6bf5f7948">set_lifecycle</a> (<a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#af7739a76fa0ebcd726b216a02d3905d2">lifecycle_type</a> t)</td></tr>
<tr class="memdesc:a985322bd233478e3c2d287d6bf5f7948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lifecycle type for the connection.  <a href="#a985322bd233478e3c2d287d6bf5f7948"></a><br/></td></tr>
<tr class="memitem:aa7367cd6719fb4991363c3cb7ac57bba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#af7739a76fa0ebcd726b216a02d3905d2">lifecycle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#aa7367cd6719fb4991363c3cb7ac57bba">get_lifecycle</a> () const </td></tr>
<tr class="memdesc:aa7367cd6719fb4991363c3cb7ac57bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lifecycle type for the connection.  <a href="#aa7367cd6719fb4991363c3cb7ac57bba"></a><br/></td></tr>
<tr class="memitem:aa416d5f72becbf7309d7b7307d22e509"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#aa416d5f72becbf7309d7b7307d22e509">get_keep_alive</a> () const </td></tr>
<tr class="memdesc:aa416d5f72becbf7309d7b7307d22e509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the connection should be kept alive.  <a href="#aa416d5f72becbf7309d7b7307d22e509"></a><br/></td></tr>
<tr class="memitem:a2bd7773f72241403044e92d8ecf7c92d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a2bd7773f72241403044e92d8ecf7c92d">get_pipelined</a> () const </td></tr>
<tr class="memdesc:a2bd7773f72241403044e92d8ecf7c92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the HTTP requests are pipelined.  <a href="#a2bd7773f72241403044e92d8ecf7c92d"></a><br/></td></tr>
<tr class="memitem:ac39803f0fa5095117922f805cad26f55"><td class="memItemLeft" align="right" valign="top">read_buffer_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#ac39803f0fa5095117922f805cad26f55">get_read_buffer</a> ()</td></tr>
<tr class="memdesc:ac39803f0fa5095117922f805cad26f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer used for reading data from the TCP connection.  <a href="#ac39803f0fa5095117922f805cad26f55"></a><br/></td></tr>
<tr class="memitem:a0ca46c85796054a510b839025e1c174c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a0ca46c85796054a510b839025e1c174c">save_read_pos</a> (const char *read_ptr, const char *read_end_ptr)</td></tr>
<tr class="memdesc:a0ca46c85796054a510b839025e1c174c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a read position bookmark.  <a href="#a0ca46c85796054a510b839025e1c174c"></a><br/></td></tr>
<tr class="memitem:af32bc0c4c9e1a9192a21e467161631ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#af32bc0c4c9e1a9192a21e467161631ca">load_read_pos</a> (const char *&amp;read_ptr, const char *&amp;read_end_ptr) const </td></tr>
<tr class="memdesc:af32bc0c4c9e1a9192a21e467161631ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a read position bookmark.  <a href="#af32bc0c4c9e1a9192a21e467161631ca"></a><br/></td></tr>
<tr class="memitem:a74b6f4bd62685e98afa94d3f26e20680"><td class="memItemLeft" align="right" valign="top">asio::ip::tcp::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a74b6f4bd62685e98afa94d3f26e20680">get_remote_endpoint</a> () const </td></tr>
<tr class="memdesc:a74b6f4bd62685e98afa94d3f26e20680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ASIO endpoint for the client connection.  <a href="#a74b6f4bd62685e98afa94d3f26e20680"></a><br/></td></tr>
<tr class="memitem:a5ebab681f028c2e9db8aec28f41c5941"><td class="memItemLeft" align="right" valign="top">asio::ip::address&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a5ebab681f028c2e9db8aec28f41c5941">get_remote_ip</a> () const </td></tr>
<tr class="memdesc:a5ebab681f028c2e9db8aec28f41c5941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the client's IP address.  <a href="#a5ebab681f028c2e9db8aec28f41c5941"></a><br/></td></tr>
<tr class="memitem:a66c34623eadf25c30a21f9a83ad99f6a"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a66c34623eadf25c30a21f9a83ad99f6a">get_remote_port</a> () const </td></tr>
<tr class="memdesc:a66c34623eadf25c30a21f9a83ad99f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the client's port number.  <a href="#a66c34623eadf25c30a21f9a83ad99f6a"></a><br/></td></tr>
<tr class="memitem:a7ca989bbe7f21459e63387f768ab6416"><td class="memItemLeft" align="right" valign="top">asio::io_service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a7ca989bbe7f21459e63387f768ab6416">get_io_service</a> ()</td></tr>
<tr class="memdesc:a7ca989bbe7f21459e63387f768ab6416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the io_service used for async operations.  <a href="#a7ca989bbe7f21459e63387f768ab6416"></a><br/></td></tr>
<tr class="memitem:aad8bf4f48ff83e2bf9984228fa1ead3c"><td class="memItemLeft" align="right" valign="top">socket_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#aad8bf4f48ff83e2bf9984228fa1ead3c">get_socket</a> ()</td></tr>
<tr class="memdesc:aad8bf4f48ff83e2bf9984228fa1ead3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-const reference to underlying TCP socket object.  <a href="#aad8bf4f48ff83e2bf9984228fa1ead3c"></a><br/></td></tr>
<tr class="memitem:ae2df0c40ebd16c2d12c066f43e2485e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection_1_1ssl__socket__type.html">ssl_socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#ae2df0c40ebd16c2d12c066f43e2485e8">get_ssl_socket</a> ()</td></tr>
<tr class="memdesc:ae2df0c40ebd16c2d12c066f43e2485e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-const reference to underlying SSL socket object.  <a href="#ae2df0c40ebd16c2d12c066f43e2485e8"></a><br/></td></tr>
<tr class="memitem:ac80fa64c43b009839e12dc135bb0e4ad"><td class="memItemLeft" align="right" valign="top">const socket_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#ac80fa64c43b009839e12dc135bb0e4ad">get_socket</a> () const </td></tr>
<tr class="memdesc:ac80fa64c43b009839e12dc135bb0e4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to underlying TCP socket object.  <a href="#ac80fa64c43b009839e12dc135bb0e4ad"></a><br/></td></tr>
<tr class="memitem:a606f1d7d69b305b70aad7d67146fe1a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection_1_1ssl__socket__type.html">ssl_socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a606f1d7d69b305b70aad7d67146fe1a2">get_ssl_socket</a> () const </td></tr>
<tr class="memdesc:a606f1d7d69b305b70aad7d67146fe1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to underlying SSL socket object.  <a href="#a606f1d7d69b305b70aad7d67146fe1a2"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a721a2ef7e9947906d1400612ea82d7e7"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html">tcp_connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a721a2ef7e9947906d1400612ea82d7e7">create</a> (asio::io_service &amp;io_service, ssl_context_type &amp;ssl_context, const bool ssl_flag, connection_handler finished_handler)</td></tr>
<tr class="memdesc:a721a2ef7e9947906d1400612ea82d7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates new shared connection objects  <a href="#a721a2ef7e9947906d1400612ea82d7e7"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a91ba8a05af749231faaadf38192ad119"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a91ba8a05af749231faaadf38192ad119">tcp_connection</a> (asio::io_service &amp;io_service, ssl_context_type &amp;ssl_context, const bool ssl_flag, connection_handler finished_handler)</td></tr>
<tr class="memdesc:a91ba8a05af749231faaadf38192ad119"><td class="mdescLeft">&#160;</td><td class="mdescRight">protected constructor restricts creation of objects (use <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a721a2ef7e9947906d1400612ea82d7e7" title="creates new shared connection objects">create()</a>)  <a href="#a91ba8a05af749231faaadf38192ad119"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represents a single tcp connection. </p>
</div><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ae5075699acd8e07b6d242f3cf70690eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the read buffer. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae5075699acd8e07b6d242f3cf70690eba5a53cbdf95cf6402baca981c3ac1edf5"></a>READ_BUFFER_SIZE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="af7739a76fa0ebcd726b216a02d3905d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#af7739a76fa0ebcd726b216a02d3905d2">staticlib::pion::tcp_connection::lifecycle_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data type for the connection's lifecycle state. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af7739a76fa0ebcd726b216a02d3905d2a332410340ccbf38c84577953e6cd5e3d"></a>LIFECYCLE_CLOSE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af7739a76fa0ebcd726b216a02d3905d2a8d28aff983d92863db399f4c6d925eea"></a>LIFECYCLE_KEEPALIVE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af7739a76fa0ebcd726b216a02d3905d2a13bede81a0795f5e0c752925a24f8ba5"></a>LIFECYCLE_PIPELINED</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a46fbdd6543ae39d83c1ba13e06407187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">staticlib::pion::tcp_connection::tcp_connection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html">tcp_connection</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>

</div>
</div>
<a class="anchor" id="adf54c5d576428f3dad96d5e9fbbd3d2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual staticlib::pion::tcp_connection::~tcp_connection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. </p>

</div>
</div>
<a class="anchor" id="a91ba8a05af749231faaadf38192ad119"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">staticlib::pion::tcp_connection::tcp_connection </td>
          <td>(</td>
          <td class="paramtype">asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssl_context_type &amp;&#160;</td>
          <td class="paramname"><em>ssl_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ssl_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">connection_handler&#160;</td>
          <td class="paramname"><em>finished_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>protected constructor restricts creation of objects (use <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#a721a2ef7e9947906d1400612ea82d7e7" title="creates new shared connection objects">create()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_service</td><td>asio service associated with the connection </td></tr>
    <tr><td class="paramname">ssl_context</td><td>asio ssl context associated with the connection </td></tr>
    <tr><td class="paramname">ssl_flag</td><td>if true then the connection will be encrypted using SSL </td></tr>
    <tr><td class="paramname">finished_handler</td><td>function called when a server has finished handling the connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a40d92a984e127cbfeed5256c88c0aefb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AcceptHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::async_accept </td>
          <td>(</td>
          <td class="paramtype">asio::ip::tcp::acceptor &amp;&#160;</td>
          <td class="paramname"><em>tcp_acceptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously accepts a new tcp connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tcp_acceptor</td><td>object used to accept new connections </td></tr>
    <tr><td class="paramname">handler</td><td>called after a new connection has been accepted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_socket_acceptor::async_accept() </dd></dl>

</div>
</div>
<a class="anchor" id="a3b074f3af081116069a4c7c876e4a150"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SSLHandshakeHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::async_handshake_server </td>
          <td>(</td>
          <td class="paramtype">SSLHandshakeHandler&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously performs server-side SSL handshake for a new connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>called after the ssl handshake has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::ssl::stream::async_handshake() </dd></dl>

</div>
</div>
<a class="anchor" id="ae8e9e3f821c8e283db153780e1c58c67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionCondition , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::async_read </td>
          <td>(</td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads data into the connection's read buffer until completion_condition is met. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::async_read() </dd></dl>

</div>
</div>
<a class="anchor" id="add5c20d2263b87338ad21791aab139bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::async_read </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads data from the connection until completion_condition is met. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers into which the data will be read </td></tr>
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::async_read() </dd></dl>

</div>
</div>
<a class="anchor" id="a4923a9f45475729adf513f759277ac1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::async_read_some </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads some data into the connection's read buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::async_read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="a409bd7aa4e217aa44c93808195bc3ceb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadBufferType , typename ReadHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::async_read_some </td>
          <td>(</td>
          <td class="paramtype">ReadBufferType&#160;</td>
          <td class="paramname"><em>read_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously reads some data into the connection's read buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_buffer</td><td>the buffer to read data into </td></tr>
    <tr><td class="paramname">handler</td><td>called after the read operation has completed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::async_read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="a5db24f8061bf474f8016f28350f4e6dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence , typename write_handler_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::async_write </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">write_handler_t&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously writes data to the connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers containing the data to be written </td></tr>
    <tr><td class="paramname">handler</td><td>called after the data has been written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>asio::async_write() </dd></dl>

</div>
</div>
<a class="anchor" id="ab543525ac858c658ab6ff4d29876402e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels any asynchronous operations pending on the socket. </p>

</div>
</div>
<a class="anchor" id="aea40b6af13e5d03da75c8c87fd000dec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the tcp socket and cancels any pending asynchronous operations. </p>

</div>
</div>
<a class="anchor" id="a721a2ef7e9947906d1400612ea82d7e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html">tcp_connection</a>&gt; staticlib::pion::tcp_connection::create </td>
          <td>(</td>
          <td class="paramtype">asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssl_context_type &amp;&#160;</td>
          <td class="paramname"><em>ssl_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ssl_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">connection_handler&#160;</td>
          <td class="paramname"><em>finished_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates new shared connection objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_service</td><td>asio service associated with the connection </td></tr>
    <tr><td class="paramname">ssl_context</td><td>asio ssl context associated with the connection </td></tr>
    <tr><td class="paramname">ssl_flag</td><td>if true then the connection will be encrypted using SSL </td></tr>
    <tr><td class="paramname">finished_handler</td><td>function called when a server has finished handling the connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76c2df67070743bebd109f343eab8aec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called when a server has finished handling the connection. </p>

</div>
</div>
<a class="anchor" id="a7ca989bbe7f21459e63387f768ab6416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::io_service&amp; staticlib::pion::tcp_connection::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reference to the io_service used for async operations. </p>
<dl class="section return"><dt>Returns</dt><dd>io_service used for async operations </dd></dl>

</div>
</div>
<a class="anchor" id="aa416d5f72becbf7309d7b7307d22e509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool staticlib::pion::tcp_connection::get_keep_alive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the connection should be kept alive. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa7367cd6719fb4991363c3cb7ac57bba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#af7739a76fa0ebcd726b216a02d3905d2">lifecycle_type</a> staticlib::pion::tcp_connection::get_lifecycle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lifecycle type for the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>lifecycle type name </dd></dl>

</div>
</div>
<a class="anchor" id="a2bd7773f72241403044e92d8ecf7c92d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool staticlib::pion::tcp_connection::get_pipelined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the HTTP requests are pipelined. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the HTTP requests are pipelined </dd></dl>

</div>
</div>
<a class="anchor" id="ac39803f0fa5095117922f805cad26f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">read_buffer_type&amp; staticlib::pion::tcp_connection::get_read_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the buffer used for reading data from the TCP connection. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer used for reading data from the TCP connection </dd></dl>

</div>
</div>
<a class="anchor" id="a74b6f4bd62685e98afa94d3f26e20680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::ip::tcp::endpoint staticlib::pion::tcp_connection::get_remote_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an ASIO endpoint for the client connection. </p>
<dl class="section return"><dt>Returns</dt><dd>endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a5ebab681f028c2e9db8aec28f41c5941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::ip::address staticlib::pion::tcp_connection::get_remote_ip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the client's IP address. </p>
<dl class="section return"><dt>Returns</dt><dd>client's IP address </dd></dl>

</div>
</div>
<a class="anchor" id="a66c34623eadf25c30a21f9a83ad99f6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short staticlib::pion::tcp_connection::get_remote_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the client's port number. </p>
<dl class="section return"><dt>Returns</dt><dd>client's port number </dd></dl>

</div>
</div>
<a class="anchor" id="aad8bf4f48ff83e2bf9984228fa1ead3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">socket_type&amp; staticlib::pion::tcp_connection::get_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-const reference to underlying TCP socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying TCP socket object </dd></dl>

</div>
</div>
<a class="anchor" id="ac80fa64c43b009839e12dc135bb0e4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const socket_type&amp; staticlib::pion::tcp_connection::get_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const reference to underlying TCP socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying TCP socket object </dd></dl>

</div>
</div>
<a class="anchor" id="a960711882583673805a4c46a62f70375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool staticlib::pion::tcp_connection::get_ssl_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the connection is encrypted using SSL. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the connection is encrypted using SSL </dd></dl>

</div>
</div>
<a class="anchor" id="ae2df0c40ebd16c2d12c066f43e2485e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection_1_1ssl__socket__type.html">ssl_socket_type</a>&amp; staticlib::pion::tcp_connection::get_ssl_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-const reference to underlying SSL socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying SSL socket object </dd></dl>

</div>
</div>
<a class="anchor" id="a606f1d7d69b305b70aad7d67146fe1a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection_1_1ssl__socket__type.html">ssl_socket_type</a>&amp; staticlib::pion::tcp_connection::get_ssl_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns const reference to underlying SSL socket object. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying SSL socket object </dd></dl>

</div>
</div>
<a class="anchor" id="ac8680cd33e5dc496a5e3e089721467d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool staticlib::pion::tcp_connection::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the connection is currently open. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the connection is currently open </dd></dl>

</div>
</div>
<a class="anchor" id="af32bc0c4c9e1a9192a21e467161631ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::load_read_pos </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>read_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>read_end_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a read position bookmark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_ptr</td><td>points to the next character to be consumed in the read_buffer </td></tr>
    <tr><td class="paramname">read_end_ptr</td><td>points to the end of the read_buffer (last byte + 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28a61b43aa04174d7ee5fa46f9ee6d24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html">tcp_connection</a>&amp; staticlib::pion::tcp_connection::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html">tcp_connection</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>

</div>
</div>
<a class="anchor" id="a49ff1778a2e20be8567407923d549ba3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t staticlib::pion::tcp_connection::read </td>
          <td>(</td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data into the connection's read buffer until completion_condition is met (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::read() </dd></dl>

</div>
</div>
<a class="anchor" id="a191460097d9a98013f65d0c96720060e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename CompletionCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t staticlib::pion::tcp_connection::read </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from the connection until completion_condition is met (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers into which the data will be read </td></tr>
    <tr><td class="paramname">completion_condition</td><td>determines if the read operation is complete </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::read() </dd></dl>

</div>
</div>
<a class="anchor" id="a4ec827d9efd92fd0f9e559ff18675bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t staticlib::pion::tcp_connection::read_some </td>
          <td>(</td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads some data into the connection's read buffer (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="a4dea910f609f794b9b49d045c7941ea8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadBufferType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t staticlib::pion::tcp_connection::read_some </td>
          <td>(</td>
          <td class="paramtype">ReadBufferType&#160;</td>
          <td class="paramname"><em>read_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads some data into the connection's read buffer (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_buffer</td><td>the buffer to read data into </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the read fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes read</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::basic_stream_socket::read_some() </dd></dl>

</div>
</div>
<a class="anchor" id="a0ca46c85796054a510b839025e1c174c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::save_read_pos </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>read_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>read_end_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a read position bookmark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_ptr</td><td>points to the next character to be consumed in the read_buffer </td></tr>
    <tr><td class="paramname">read_end_ptr</td><td>points to the end of the read_buffer (last byte + 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a985322bd233478e3c2d287d6bf5f7948"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void staticlib::pion::tcp_connection::set_lifecycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstaticlib_1_1pion_1_1tcp__connection.html#af7739a76fa0ebcd726b216a02d3905d2">lifecycle_type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the lifecycle type for the connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>lifecycle type name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba716e2b4c3c817fc33d54ba5ae32448"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t staticlib::pion::tcp_connection::write </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the connection (blocks until finished) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>one or more buffers containing the data to be written </td></tr>
    <tr><td class="paramname">ec</td><td>contains error code if the write fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t number of bytes written</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>asio::write() </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>staticlib/pion/<a class="el" href="tcp__connection_8hpp_source.html">tcp_connection.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 31 2017 15:31:24 for staticlib_pion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
